<!DOCTYPE html>
<html lang=en>
<head>
<title>SPA Gatsby Document Template</title>
<script type=module>
// legacy support, hacking
let exports = null;
const cache = {};
globalThis.basepath = '';
const queue = new Set([]);
globalThis.process = {env:{}};
globalThis.require = function require(path){
	const url = new URL(`${ basepath }/${ path }`, location);
	const { pathname } = url;
	cache[pathname] = null;
	const req = import(url)
	.then(res=>{
		const payload = exports;
		cache[pathname] = payload;
		// reset for next
		exports = null;
		queue.delete(req);
		return Promise.all(queue);
	})
	.catch(res=>{
		console.warn({basepath, path, url, pathname, res});
		console.error(res);
		queue.delete(req);
	})
	;
	queue.add(req);
	function required(){
		return cache[pathname];
	};
	required.request = req;
	required[Symbol.iterator] = iterator;
	return required;
}
function unrequire(hash){
	const type = typeof hash;
	if(type !== 'object') return;
	Object.entries(hash)
	.forEach(([key,item], i, all)=>{
		const type = typeof item;
		if('function' === type){
			const value = item();
			if(item.spread){
				// spread what came in from here
				hash.splice(i, 1, ...value);
			}else{
				hash[key] = value;
			}
		}else{
			unrequire(item);
		}
	})
	;
	return hash;
}
function iterator(){
		let index = 0;
		// update later in place
		this.spread = true;
		const value = this;
	return {
		next() {
			if(index > 0) return { done: true };
			index++;
			return { value, done: false }
		}
	}
}
globalThis.module = new Proxy({exports}, {
	set(target, key, val, pxy){
		exports = val;
		return true;
	}
});

import { Lit, markdown } from './deps.js';
const { LitElement, html, css, svg } = Lit;
const md = new markdown.Remarkable();
console.log(md.render(`# markdown *here*?`), {Lit,markdown});

class UndoDocs extends HTMLElement{
	static cache = cache;
	static queue = queue;
	static __md = md;
	static markdown = md.render.bind(md);
	static pending = [];
	static busy = false;
	constructor(){
		super();
		this.docs = null;
		this.basepath = '';

		this.attachShadow({mode:'open'}).innerHTML = `
			<style>
			:host(:hover){background-color:var(--golden, #ddd);position:relative;}
			:slotted{font-weight:normal;}
			slot[name="source"]{color:var(--blue, #555);}
			slot[name="source"]::slotted(*){position:absolute;bottom:0;right:1em;}
			</style>
			<textarea></textarea>
			<slot>view</slot>
		`;
		this._loaded = this._loaded.bind(this);
	}

	get src(){
		return this.getAttribute('src') ?? '';
	}

	set src(url=''){
		this.setAttribute('src', url);
	}
	get theme(){
		return this.getAttribute('theme') ?? '';
	}

	set theme(url=''){
		url ? this.setAttribute('theme', url) : this.removeAttribute('theme');
	}

	markdown(content){
		return UndoDocs.markdown(content);
	}


	resolve(path){
		return new URL(`${ this.basepath }${ path }`, location);
	}

	_loaded({type, detail}){
		const { src, docs, url, path} = detail;
		if(src !== this.src) return;
		this.docs = docs;
		this.url = url;
		this.path = path;
		this.basepath = path.basepath;
		console.warn(type, {src, docs, url, path});
		this.render();
	}

	connectedCallback(){
		self.addEventListener('undo-loaded-docs', this._loaded);
//		if(!this.docs && this.src) this.load();
	}

	disconnectedCallback(){
		self.removeEventListener('undo-loaded-docs', this._loaded);
	}

	loadTheme(src=this.theme){
		if(!src) return Promise.resolve(this._theme);

		this.setAttribute('loading-theme', '');
		return import(src)
		.then(res=>{
			const { theme, localName = '' } = res;
			if(!localName){
			// try to get from filename in src
				const parts = src.toLowerCase().split('/');
				
			}

			console.warn(`theme TODO TBD`, {theme});

			this._theme = theme;
			return theme;
		})
		.finally(()=>{
			this.removeAttribute('loading-theme');
		});
		;
	}

	static get observedAttributes() { return ['src', 'theme']; }

	attributeChangedCallback(name, old, value=''){
		switch(name){
		case 'src':
			if(value) this.load();
		break;
		case 'theme':
			this.loadTheme();
		break;
		}
	}

	renderPage(html){
		cancelAnimationFrame(this._renderPage);
		this._renderPage = requestAnimationFrame(()=>{
			this.innerHTML = html;
		});
	}

	render(){
		cancelAnimationFrame(this._render);
		this._render = requestAnimationFrame(()=>{
			Array.from(this.children).forEach(node=>node.remove());
			const { docs = null } = this;
			this.shadowRoot.querySelector('textarea').innerHTML = JSON.stringify(docs);
			if( !docs ) return;
			this.fetchm(docs.siteMetadata.pages[0].path).then(res=>{ 
				this.renderPage(res.html); 
			});
		});
	}

	load(){
		this.setAttribute('loading','');
		return UndoDocs.load(this.src)
		.finally(()=>{
			this.removeAttribute('loading');
		})
		;
	}
	// fetch markdown files
	// fetch(this.docs.siteMetadata.pages[0].path);
	// fetch('/').then
	fetchm(req='/'){
		let path = `${this.basepath}/src/pages${ req }`;
		if(path.endsWith('/')) path += 'index.md';
		return fetch(path)
		.then(res=>res.text())
		.then(text=>{
			let html, error;
			try{
				html = this.markdown(text);
			}catch(err){
				error = err;
				console.error(err);
			};
			return {text, html, error}
		});
	}
	
	static path(pathname=''){
		if(pathname.pathname){
			// for URL, Location instances
			pathname = pathname.pathname;
		}
		const trailingSlash = pathname.endsWith('/');
		const pre = pathname.split('/');
		const file = pre.pop();
		const fparts = file.split('.');
		const ext = fparts.length > 1 ? fparts[fparts.length-1] : '';
		const [empty, ...dirs] = pre;
		const basepath = pre.join('/');
		return {pathname, basepath, pre, dirs, file, ext};
	}

	static load(src=`./gatsby-config.js`){
		let config = src;
		if(this.busy){
			let resume;
			const later = ()=>{ return this.load(src); };
			const promise = new Promise(function(resolve, reject){
				resume = function(){
					return resolve(later());
				}
			});
			this.pending.push(resume);
			return promise;
		}
		this.busy = true;
		const url = new URL(config, location);
		const path = this.path(url);
		// generally gatsby-config is assumed to be in the root of each
		// set the basepath for respective things loading
		// remote the file part
		config = path.file;
		globalThis.basepath = path.basepath;
		const req = require(config);
		return req.request
			.finally(()=>{
				this.busy = false;
				const { cache } = this;
				const result = unrequire( cache[ url.pathname ] );
				const detail = {docs: result, src, url, path};
				self.dispatchEvent(new CustomEvent('undo-loaded-docs', {detail, bubbles: true, composed: true}));
				const next = this.pending.shift();
				if(next){
					next()
				}
			});
	}
}

customElements.define('undo-docs', UndoDocs);
</script>
</head>
<style>

</style>
<body>
UndoDocs
	<undo-docs src="./docs1/gatsby-config.js" theme="./theme-tag.js">docs1</undo-docs>
	<undo-docs src="./docs2/gatsby-config.js" theme="./theme-tag.js">docs2</undo-docs>
</body>
</html>
