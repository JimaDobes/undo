<!DOCTYPE html>
<html lang=en>
<head>
<title>SPA Gatsby Document Template</title>
<script type=module>
// legacy support, hacking
let exports = null;
const cache = {};
let basepath = '';
const queue = new Set([]);
globalThis.process = {env:{}};
globalThis.require = function require(path){
	const url = new URL(`${ basepath }/${ path }`, location);
	const { pathname } = url;
	cache[pathname] = null;
	const req = import(url)
	.then(res=>{
		const payload = exports;
		cache[pathname] = payload;
		// reset for next
		exports = null;
		queue.delete(req);
		return Promise.all(queue);
	})
	.catch(res=>{
		console.warn({basepath, path, url, pathname, res});
		console.error(res);
		queue.delete(req);
	})
	;
	queue.add(req);
	function required(){
		return cache[pathname];
	};
	required.request = req;
	required[Symbol.iterator] = iterator;
	return required;
}
function unrequire(hash){
	const type = typeof hash;
	if(type !== 'object') return;
	Object.entries(hash)
	.forEach(([key,item], i, all)=>{
		const type = typeof item;
		if('function' === type){
			const value = item();
			if(item.spread){
				// spread what came in from here
				hash.splice(i, 1, ...value);
			}else{
				hash[key] = value;
			}
		}else{
			unrequire(item);
		}
	})
	;
	return hash;
}
function iterator(){
		let index = 0;
		// update later in place
		this.spread = true;
		const value = this;
	return {
		next() {
			if(index > 0) return { done: true };
			index++;
			return { value, done: false }
		}
	}
}
globalThis.module = new Proxy({exports}, {
	set(target, key, val, pxy){
		exports = val;
		return true;
	}
});

import { Lit, markdown } from './deps.js';
const { LitElement, html, css, svg } = Lit;
const md = new markdown.Remarkable();
console.log(md.render(`# markdown *here*?`), {Lit,markdown});

/* generally manage loading content and tracking shared concerns
 */
class UndoDocs extends HTMLElement{
	static cache = cache;
	static queue = queue;
	static __md = md;
	static markdown = md.render;
	pending = [];
	busy = false;
	constructor(){
		super();
		this.attachShadow({mode:'open'}).innerHTML = `
			<style>
			:host(:hover){background-color:var(--golden, #ddd);position:relative;}
			:slotted{font-weight:normal;}
			slot[name="source"]{color:var(--blue, #555);}
			slot[name="source"]::slotted(*){position:absolute;bottom:0;right:1em;}
			</style>
			<slot></slot>
		`;

		this.addEventListener('undo-load-docs', this._load);
	}
	// this hasn't been tried with multiple projects
	load(src=`./gatsby-config.js`){
		let config = src;
		if(this.busy){
			this.pending.push(config);
			return;
		}
		this.busy = true;
		const url = new URL(config, location);
		const { pathname } = url;
		// generally gatsby-config is assumed to be in the root of each
		// set the basepath for respective things loading
		const parts = pathname.split('/');
		if(parts.length > 2){
			config = parts.pop();
			basepath = parts.join('/');
		}
		const req = require(config);
		req.request
			.finally(()=>{
				this.busy = false;
				
				const { cache } = UndoDocs;
				const result = unrequire( cache[ pathname ] );
				const detail = {docs: result, src, url};
				this.dispatchEvent(new CustomEvent('undo-loaded-docs', {detail, bubbles: true, composed: true}));
				const next = this.pending.shift();
				if(next) this.load(next);
			});
	}

	connectedCallback(){
		const nodes = this.ownerDocument.querySelectorAll(this.localName);
		if(nodes.length > 1){
			throw new Error(`there should only be one ${this.localName} element per document to prevent conflicts when loading content`);
		}
	}

	markdown(content){
		return UndoDocs.markdown(content);
	}

	_load({type, detail}){
		this.load(detail);
	}
}

customElements.define('undo-docs', UndoDocs);


class UndoView extends HTMLElement{
	constructor(){
		super();
		this.docs = null;

		this.attachShadow({mode:'open'}).innerHTML = `
			<style>
			:host(:hover){background-color:var(--golden, #ddd);position:relative;}
			:slotted{font-weight:normal;}
			slot[name="source"]{color:var(--blue, #555);}
			slot[name="source"]::slotted(*){position:absolute;bottom:0;right:1em;}
			</style>
			<slot>view</slot>
			<textarea></textarea>
		`;
		this._load = this._load.bind(this);
	}

	get src(){
		return this.getAttribute('src') ?? '';
	}

	set src(url=''){
		this.setAttribute('src', url);
	}

	resolve(path){
		return new URL(`${ this.basepath }${ path }`, location);
	}

	_load({type, detail}){
		const { src, docs, url } = detail;
		if(src !== this.src) return;
		this.docs = docs;
		this.url = url;
		const parts = url.pathname.split('/');
		parts.pop();
		this.basepath = parts.join('/');
		console.warn(type, {src, docs, url});
		this.render();
	}

	connectedCallback(){
		self.addEventListener('undo-loaded-docs', this._load);
	}

	disconnectedCallback(){
		self.removeEventListener('undo-loaded-docs', this._load);
	}

	static get observedAttributes() { return ['src']; }

	attributeChangedCallback(name, old, value=''){
		if('src' === name){
			this.dispatchEvent(new CustomEvent('undo-load-docs', {detail:value, bubbles:true, composed: true}));
		};
	}

	render(){
		cancelAnimationFrame(this._render);
		this._render = requestAnimationFrame(()=>{
			Array.from(this.children).forEach(node=>node.remove());
			const { docs = null } = this;
			this.shadowRoot.querySelector('textarea').innerHTML = JSON.stringify(docs);
		});
	}
}

customElements.define('undo-view', UndoView);
</script>
</head>
<style>

</style>
<body>
<undo-docs>UndoDocs
	<undo-view src="./docs1/gatsby-config.js">docs1</undo-view>
	<undo-view src="./docs2/gatsby-config.js">docs2</undo-view>
</undo-docs>
</body>
</html>
